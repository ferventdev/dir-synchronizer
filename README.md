# Directories Synchronizer

Данная программа представляет собой консольную утилиту, осуществляющую однонаправленную синхронизацию
между некоторыми исходной и целевой (копирующей исходную) директориями, пути к которым передаются ей в качестве
параметров.

## Использование программы

Для использования программы необходима утилита `make` (в проекте есть `Makefile`),
которая обычно есть в большинстве *NIX систем.

Перед запуском программы синхронизации необходимо в своей файловой системе выбрать две разные директории:

1) исходную - программа будет читать её содержимое, но не будет модифицировать его, т.е. данная директория
   будет источником для синхронизации;
2) целевую (копирующую исходную) - программа будет как читать, так и активно модифицировать её
   содержимое, т.е. данная директория будет в результате процесса синхронизации стремиться "повторять" содержимое
   исходной.

### Запуск программы

После клонирования репозитория перейдите внутрь его каталога и из него выполните:

`make run srcdir=/path/to/source/dir copydir=/path/to/mirror/dir`

где в параметрах `srcdir` и `copydir` должны быть указаны пути (необязательно абсолютные, можно относительные) к
соответственно исходной директории и целевой директории-копии.

Например, в качестве проверки можно запустить:

`make run srcdir=tmp/sample-dirs/src copydir=tmp/sample-dirs/copy`

(эти директории для удобства проверки уже есть в каталоге программы).

Данная команда соберёт проект и запустит процесс однонаправленной синхронизации между этими директориями *в фоновом
режиме*.
После этого любая модификация содержимого (файлов и директорий) внутри исходной директории будет
отражена и в копирующей директории. При этом соответствующие события синхронизации будут автоматически логироваться
(с уровня *INFO* и выше) в локальный файл `tmp/log.txt` каталога с программой.
В конечном итоге файловые поддеревья обеих директорий будут совпадать, т.е. имя, размер и время модификации файла
для любого узла в первом поддереве не будут отличаться от них для соответствующего ему (с т.з. локального
пути в поддереве) узла во втором поддереве.

### Останов программы

Из каталога с программой выполните либо `make stop` для остановки всех процессов синхронизации, которые были запущены с
помощью данной программы (ведь ничто не мешает вам запускать несколько процессов, например для разных пар директорий),
либо же `make stoplast`, если хотите
остановить лишь один процесс синхронизации, запущенный последним.

### Запуск программы в отладочном режиме

Из каталога с программой выполните:

`make debug srcdir=/path/to/source/dir copydir=/path/to/mirror/dir`

где в параметрах `srcdir` и `copydir` должны быть указаны пути к соответственно исходной директории и целевой
директории-копии.

Данная команда запустит процесс однонаправленной синхронизации между этими директориями с некоторыми включёнными
debug-опциями (в частности, будет включён race-детектор, а логирование будет идти в саму консоль с уровня *DEBUG* и
выше) и уже не в фоновом режиме, а в *foreground* вашей консоли. Для останова вам достаточно будет нажать *Ctrl+C* в
вашей консоли.

### Прогон тестов

Из каталога с программой выполните `make test` для прогона всех тестов в проекте. Эта команда также отобразит
примерное итоговое тестовое покрытие кода.

### Запуск бенчмарка

Из каталога с программой выполните `make bench` для запуска бенчмарка для функции копирования файла.

### Прочие возможности

- Для сборки проекта (без запуска программы) выполните `make build`.
- Для вывода списка всех запущенных процессов синхронизации (запущенных с помощью данной программы)
  выполните `make getpid`.
- Для отображения справки по всем командам (т.е. по всем доступным make targets) выполните `make help` или просто `make`
  .

## Особенности программной реализации

### Архитектура

В приложении организована очередь задач (на базе обычного Go-канала). После запуска разворачивается пул "воркеров"
(горутин) определённого размера (количество горутин можно переопределить в настройках). Каждый воркер постоянно пытается
взять из очереди имеющуюся задачу и выполнить её. Каждая задача в себе содержит все данные, необходимые для выполнения
синхронизационной операции. Тем временем, основная горутина программы циклически сканирует обе директории, сравнивает
их и на базе этого сравнения планирует задачи по устранению разницы между ними путём модификации содержимого в целевой
(копирующей) директории. Запланированные задачи ставятся в ту самую очередь задач, упомянутую выше.

Основной структурой данной в приложении является мапа, защищённая мьютексом (DirEntriesMap).
Ключами мапы являются локальные пути к узлам поддерева с корнем в директории (исходной / копирующей), а значениями -
структуры, содержащие в себе данные об этих узлах как в исходной, так и в копирующей директории. Благодаря этому, в
каждый момент времени по любому ключу мапы (т.е. по пути любого узла) можно судить о наличии разницы по этому узлу.
Мапа обновляется в результате регулярного "сканирования" директорий (период можно переопределить в настройках),
а также при выполнении запланированных операций по их синхронизации.

Сканирование директорий и планирование задач производится быстро и просто, т.к. при сравнении файлов учитываются только
их имена, размеры и время последней модификации, но не их внутреннее содержимое (т.е. отсутствует например подсчёт
контрольной суммы файла, и тем более его полное прочтение). По этой причине для каждого скопированного файла специально
устанавливается то же самое время последней модификации, что и у оригинала.

Некоторые прочие детали:

- возможные статусы синхронизационных операций: *scheduled*, *in_progress*, *canceled*, *failed*, *completed*;
- разновидности синхронизационных операций: *copy_file*, *copy_dir*, *remove_file*, *remove_dir*, *replace_file*,
  *replace_dir_with_file*;
- перед началом выполнения воркером очередной задачи данные этой задачи актуализируются, т.к. с момента её постановки в
  очередь уже могло пройти какое-то время, за которое что-то могло ещё раз измениться;
- предусмотрен механизм отмены незаконченной операции, если в ходе очередного сканирования обнаруживается, что в ней
  уже нет необходимости.

### Настройки программы

Внутри программы имеется определённый набор настроек, некоторые из которых явно указываются при реализации make targets
(см. в `Makefile`), а некоторые не указываются явно, и задействуются их значения по умолчанию.

Тем не менее, если запускать собранный бинарник с программой (для сборки можно использовать `make build`) напрямую без
`make`, то с помощью флагов и аргументов команды запуска все эти настройки можно явно задавать. Для этого внутри
используется пакет `flag` стандартной библиотеки. В частности, есть и такие потенциально полезные параметры настроек:

- `-hidden` - нужно ли синхронизировать в т.ч. т.н. скрытые файлы и директории (имена которых начинаются с .), по
  умолчанию `false`;
- `-once` - позволяет запустить программу для "разовой" синхронизации, т.е. выполнится один синхро-цикл и программа
  довольно быстро завершится, по умолчанию `false`;
- `-log2std` - выводить ли логи в консоль вместо файла, по умолчанию `false`;
- `-pid` - выводить ли в консоль при запуске программы PID запущенного процесса, по умолчанию `false`;
- `-scanperiod` - период "сканирования" исходной директории и планирования операций по синхронизации, по умолчанию 1
  секунда;
- `-workers` - размер пула горутин, выполняющих собственно сами синхронизационные операции, по умолчанию
  равен `runtime.NumCPU()`;
- `-loglvl` - для задания уровня логирования, по умолчанию *INFO*.

### Использованные внешние зависимости

Если не считать библиотеки, используемые для тестов (**stretchr/testify** и **golang/mock**), то в проекте использована
только одна зависимость, а именно - логгер (**zap**).

Для удобства все зависимости проекта уже "завендорены" в репозитории.

### Логирование

При логировании есть 4 уровня: *DEBUG, INFO, WARN, ERROR*. При обычном запуске (`make run ...`) активен уровень *INFO*,
а при запуске в режиме отладки (`make debug ...`) - уровень *DEBUG*. Разумеется, при выборе определённого уровня будут
логироваться сообщения и более высоких уровней.

В лог пишутся: уровень (см. выше), время записи, id и разновидность синхронизационной операции, её статус, частичный
(относительный) путь к синхронизируемому объекту (файлу или директории). А также: время, когда операция была
запланирована, когда начата и когда успешно завершена или отменена (например, до её завершения выяснилось, что она уже
не нужна).

Логирование осуществляется в локальный файл `tmp/log.txt` (относительно каталога с программой). Этот файл один, его
местоположение не меняется, какая-либо ротация не реализована.

В настройках есть опция, позволяющая писать лог прямо в консоль вместо файла, и эта опция используется при запуске
программы в режиме отладки.

### Замечание об операционной системе

Make targets внутри Makefile написаны в расчёте на выполнение в оболочках shell / bash / zsh / etc. и некоторые их
базовые утилиты или консольные программы ОС: `cd`, `rm`, `echo`, `grep`, `pgrep`, `pkill`.
Предполагается, что все они имеются в современных *NIX системах, включая Linux и MacOS.
